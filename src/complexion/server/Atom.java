package complexion.server;


import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import complexion.resource.Sprite;
import complexion.common.Utils;
/**
 * Server-side representation of a game Atom.
 * 
 * This includes game-logic stuff, such as atom-interaction(Bump, Enter, etc.),
 * verbs, user-defined functions and so on.
 */
public class Atom {
		// TODO: Think about making these vars private,
		//       and providing getters/setters instead

		/// Unique ID of the object, generated by the server.
		private int UID; 
		
		/// Sprite the object is currently associated with.
		// TODO: get/set for this
		private Sprite sprite;  
		
		/// Determines whether the object will be rendered above or
		/// below other objects
		// TODO: get/set for this
		private int layer;
		
		/// Each sprite has multiple states, which are more or less
		/// sprites of their own. sprite_state determines which state
		/// is used.
		// TODO: get/set for this
		private String sprite_state;
		
		// TODO: Add a way for the server to restart an animation
		//       (similar to the BYOND flick proc)
		
		/// A sprite can define different appearances depending on the
		/// direction. This variable should be one of the constants defined
		/// in complexion.Directions
		private int direction;
		
		/// What this is located inside
		/// If this is at the bottom of the tile then it should not be assigned to anything
		private Atom location;
		
		/**
		 * @return The UID of this atom.
		 */
		public int getUID()
		{
			return UID;
		}
		
		/**
		 * @param new_state The new sprite state of the atom.
		 */
		// TODO: Make this do whatever stuff is required for the updates to be sent to client.
		public void setSpriteState(String new_state)
		{
			sprite_state = new_state;
		}
		
		/**
		 * @return The current sprite state string.
		 */		
		// TODO: Make this do whatever stuff is required for the updates to be sent to client.
		public String getSpriteState()
		{
			return sprite_state;
		}
		
		/**
		 * @param new_dir The new facing of the object.
		 */
		// TODO: Make this do whatever stuff is required for the updates to be sent to client.
		public void setDirection(int new_dir)
		{
			direction = new_dir;
		}
		
		/**
		 * @return The current facing of the object.
		 */
		public int getDirection()
		{
			return direction;
		}
		
		/**
		 * @return Whatever this is directly inside of.
		 */
		public Atom getLoc()
		{
			if(location != null)
				return location;
			else
				return null;
		}
		
		/**
		 * For directly moving this inside something else
		 * 
		 * @param new_loc The new location of the atom.
		 */
		// TODO: Make this do whatever stuff is required for the updates to be sent to client.
		public void setLoc(Atom new_loc)
		{
			location = new_loc;
		}
		
		/**
		 * @return The tile at the bottom of whatever this is inside.
		 */
		public Atom getTile()
		{
			Atom tile = this;
			// Loops down to the bottom of wherever this atom is
			while((tile = tile.getLoc()) != null){}
			return tile;
		}
		
		/**
		 * @return The x location of the tile the atom is in.
		 */
		public int getX()
		{
			return this.getTile().getX();
		}
		
		/**
		 * @return The y location of the tile the atom is in.
		 */
		public int getY()
		{
			return this.getTile().getY();
		}
		
		/**
		 * Call an atom verb with the given name(key) and arguments.
		 * TODO: Make sure only functions we expressly make available over the network
		 * 		 can be called this way.
		 * 
		 * @param key Name of the function/verb to be called.
		 * @param args A list of objects to be passed as args. These objects will be type-checked
		 * 			   before being passed to the function.
		 * @return true on success, false on failure
		 */
		@SuppressWarnings("rawtypes")
		public boolean callVerb(String key,Object[] args)
		{
			Class[] classes = Utils.toClasses(args);
			Method func;
			try {
				func = this.getClass().getMethod(key,classes);
			} catch (SecurityException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return false;
			} catch (NoSuchMethodException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				return false;
			}
			if(func!= null)
			{
				try {
					func.invoke(this, args);
				} catch (IllegalArgumentException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (IllegalAccessException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (InvocationTargetException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				return true;
			}
			else 
				return false;
		}

}
